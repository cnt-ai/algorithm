diff --git a/yacl/math/mpint/tommath_ext_features.cc b/yacl/math/mpint/tommath_ext_features.cc
index cd9c019..073a829 100644
--- a/yacl/math/mpint/tommath_ext_features.cc
+++ b/yacl/math/mpint/tommath_ext_features.cc
@@ -28,6 +28,340 @@ extern "C" {
 #include "yacl/math/mpint/mp_int_enforce.h"
 #include "yacl/utils/scope_guard.h"
 
+//=================================libtomath=================================
+void mp_clear(mp_int *a)
+{
+  /* only do anything if a hasn't been freed previously */
+  if (a->dp != NULL) {
+    /* free ram */
+    MP_FREE_DIGS(a->dp, a->alloc);
+
+    /* reset members to make debugging easier */
+    a->dp    = NULL;
+    a->alloc = a->used = 0;
+    a->sign  = MP_ZPOS;
+  }
+}
+mp_err mp_init_size(mp_int *a, int size)
+{
+  if (size < 0) {
+    return MP_VAL;
+  }
+
+  size = MP_MAX(MP_MIN_DIGIT_COUNT, size);
+
+  if (size > MP_MAX_DIGIT_COUNT) {
+    return MP_OVF;
+  }
+
+  /* alloc mem */
+  a->dp = (mp_digit *) MP_CALLOC((size_t)size, sizeof(mp_digit));
+  if (a->dp == NULL) {
+    return MP_MEM;
+  }
+
+  /* set the members */
+  a->used  = 0;
+  a->alloc = size;
+  a->sign  = MP_ZPOS;
+
+  return MP_OKAY;
+}
+void s_mp_zero_digs(mp_digit *d, int digits)
+{
+#ifdef MP_USE_MEMOPS
+  if (digits > 0) {
+    memset(d, 0, (size_t)digits * sizeof(mp_digit));
+  }
+#else
+  while (digits-- > 0) {
+    *d++ = 0;
+  }
+#endif
+}
+mp_err mp_grow(mp_int *a, int size)
+{
+  if (size < 0) {
+    return MP_VAL;
+  }
+
+  /* if the alloc size is smaller alloc more ram */
+  if (a->alloc < size) {
+    mp_digit *dp;
+
+    if (size > MP_MAX_DIGIT_COUNT) {
+      return MP_OVF;
+    }
+
+    /* reallocate the array a->dp
+     *
+     * We store the return in a temporary variable
+     * in case the operation failed we don't want
+     * to overwrite the dp member of a.
+     */
+    dp = (mp_digit *) MP_REALLOC(a->dp,
+                                 (size_t)a->alloc * sizeof(mp_digit),
+                                 (size_t)size * sizeof(mp_digit));
+    if (dp == NULL) {
+      /* reallocation failed but "a" is still valid [can be freed] */
+      return MP_MEM;
+    }
+
+    /* reallocation succeeded so set a->dp */
+    a->dp = dp;
+
+    /* zero excess digits */
+    s_mp_zero_digs(a->dp + a->alloc, size - a->alloc);
+    a->alloc = size;
+  }
+  return MP_OKAY;
+}
+#ifdef MP_USE_MEMOPS
+#  include <string.h>
+#endif
+void s_mp_copy_digs(mp_digit *d, const mp_digit *s, int digits)
+{
+#ifdef MP_USE_MEMOPS
+  if (digits > 0) {
+    memcpy(d, s, (size_t)digits * sizeof(mp_digit));
+  }
+#else
+  while (digits-- > 0) {
+    *d++ = *s++;
+  }
+#endif
+}
+mp_err mp_copy(const mp_int *a, mp_int *b)
+{
+  mp_err err;
+
+  /* if dst == src do nothing */
+  if (a == b) {
+    return MP_OKAY;
+  }
+
+  /* grow dest */
+  if ((err = mp_grow(b, a->used)) != MP_OKAY) {
+    return err;
+  }
+
+  /* copy everything over and zero high digits */
+  s_mp_copy_digs(b->dp, a->dp, a->used);
+  s_mp_zero_digs(b->dp + a->used, b->used - a->used);
+  b->used = a->used;
+  b->sign = a->sign;
+
+  return MP_OKAY;
+}
+mp_err mp_init_copy(mp_int *a, const mp_int *b)
+{
+  mp_err     err;
+
+  if ((err = mp_init_size(a, b->used)) != MP_OKAY) {
+    return err;
+  }
+
+  if ((err = mp_copy(b, a)) != MP_OKAY) {
+    mp_clear(a);
+  }
+
+  return err;
+}
+static const struct {
+  int k, t;
+} sizes[] = {
+  {    80, -1 }, /* Use deterministic algorithm for size <= 80 bits */
+  {    81, 37 }, /* max. error = 2^(-96)*/
+  {    96, 32 }, /* max. error = 2^(-96)*/
+  {   128, 40 }, /* max. error = 2^(-112)*/
+  {   160, 35 }, /* max. error = 2^(-112)*/
+  {   256, 27 }, /* max. error = 2^(-128)*/
+  {   384, 16 }, /* max. error = 2^(-128)*/
+  {   512, 18 }, /* max. error = 2^(-160)*/
+  {   768, 11 }, /* max. error = 2^(-160)*/
+  {   896, 10 }, /* max. error = 2^(-160)*/
+  {  1024, 12 }, /* max. error = 2^(-192)*/
+  {  1536, 8  }, /* max. error = 2^(-192)*/
+  {  2048, 6  }, /* max. error = 2^(-192)*/
+  {  3072, 4  }, /* max. error = 2^(-192)*/
+  {  4096, 5  }, /* max. error = 2^(-256)*/
+  {  5120, 4  }, /* max. error = 2^(-256)*/
+  {  6144, 4  }, /* max. error = 2^(-256)*/
+  {  8192, 3  }, /* max. error = 2^(-256)*/
+  {  9216, 3  }, /* max. error = 2^(-256)*/
+  { 10240, 2  }  /* For bigger keysizes use always at least 2 Rounds */
+};
+/* returns # of RM trials required for a given bit size */
+int mp_prime_rabin_miller_trials(int size)
+{
+  int x;
+
+  for (x = 0; x < (int)(sizeof(sizes)/(sizeof(sizes[0]))); x++) {
+    if (sizes[x].k == size) {
+      return sizes[x].t;
+    }
+    if (sizes[x].k > size) {
+      return (x == 0) ? sizes[0].t : sizes[x - 1].t;
+    }
+  }
+  return sizes[x-1].t;
+}
+
+#ifndef MP_DEV_URANDOM
+#define MP_DEV_URANDOM "/dev/urandom"
+#endif
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+static mp_err s_read_urandom(void *p, size_t n)
+{
+  int fd;
+  char *q = (char *)p;
+
+  do {
+    fd = open(MP_DEV_URANDOM, O_RDONLY);
+  } while ((fd == -1) && (errno == EINTR));
+  if (fd == -1) return MP_ERR;
+
+  while (n > 0u) {
+    ssize_t ret = read(fd, q, n);
+    if (ret < 0) {
+      if (errno == EINTR) {
+        continue;
+      }
+      close(fd);
+      return MP_ERR;
+    }
+    q += ret;
+    n -= (size_t)ret;
+  }
+
+  close(fd);
+  return MP_OKAY;
+}
+mp_err s_mp_rand_platform(void *p, size_t n)
+{
+  mp_err err = MP_ERR;
+  //if ((err != MP_OKAY) && MP_HAS(S_READ_ARC4RANDOM)) err = s_read_arc4random(p, n);
+  //if ((err != MP_OKAY) && MP_HAS(S_READ_WINCSP))     err = s_read_wincsp(p, n);
+  //if ((err != MP_OKAY) && MP_HAS(S_READ_GETRANDOM))  err = s_read_getrandom(p, n);
+  if ((err != MP_OKAY) && MP_HAS(S_READ_URANDOM))    err = s_read_urandom(p, n);
+  return err;
+}
+mp_err mp_prime_rand(mp_int *a, int t, int size, int flags)
+{
+   uint8_t *tmp, maskAND, maskOR_msb, maskOR_lsb;
+   int bsize, maskOR_msb_offset;
+   bool res;
+   mp_err err;
+
+   /* sanity check the input */
+   if (size <= 1) {
+      return MP_VAL;
+   }
+
+   /* MP_PRIME_SAFE implies MP_PRIME_BBS */
+   if ((flags & MP_PRIME_SAFE) != 0) {
+      flags |= MP_PRIME_BBS;
+   }
+
+   /* calc the byte size */
+   bsize = (size>>3) + ((size&7)?1:0);
+
+   /* we need a buffer of bsize bytes */
+   tmp = (uint8_t *) MP_MALLOC((size_t)bsize);
+   if (tmp == NULL) {
+      return MP_MEM;
+   }
+
+   /* calc the maskAND value for the MSbyte*/
+   maskAND = ((size&7) == 0) ? 0xFFu : (uint8_t)(0xFFu >> (8 - (size & 7)));
+
+   /* calc the maskOR_msb */
+   maskOR_msb        = 0;
+   maskOR_msb_offset = ((size & 7) == 1) ? 1 : 0;
+   if ((flags & MP_PRIME_2MSB_ON) != 0) {
+      maskOR_msb       |= (uint8_t)(0x80 >> ((9 - size) & 7));
+   }
+
+   /* get the maskOR_lsb */
+   maskOR_lsb         = 1u;
+   if ((flags & MP_PRIME_BBS) != 0) {
+      maskOR_lsb     |= 3u;
+   }
+
+   do {
+      /* read the bytes */
+      if ((err = s_mp_rand_platform(tmp, (size_t)bsize)) != MP_OKAY) {
+         goto LBL_ERR;
+      }
+
+      /* work over the MSbyte */
+      tmp[0]    &= maskAND;
+      tmp[0]    |= (uint8_t)(1 << ((size - 1) & 7));
+
+      /* mix in the maskORs */
+      tmp[maskOR_msb_offset]   |= maskOR_msb;
+      tmp[bsize-1]             |= maskOR_lsb;
+
+      /* read it in */
+      /* TODO: casting only for now until all lengths have been changed to the type "size_t"*/
+      if ((err = mp_from_ubin(a, tmp, (size_t)bsize)) != MP_OKAY) {
+         goto LBL_ERR;
+      }
+
+      /* is it prime? */
+      if ((err = mp_prime_is_prime(a, t, &res)) != MP_OKAY) {
+         goto LBL_ERR;
+      }
+      if (!res) {
+         continue;
+      }
+
+      if ((flags & MP_PRIME_SAFE) != 0) {
+         /* see if (a-1)/2 is prime */
+         if ((err = mp_sub_d(a, 1uL, a)) != MP_OKAY) {
+            goto LBL_ERR;
+         }
+         if ((err = mp_div_2(a, a)) != MP_OKAY) {
+            goto LBL_ERR;
+         }
+
+         /* is it prime? */
+         if ((err = mp_prime_is_prime(a, t, &res)) != MP_OKAY) {
+            goto LBL_ERR;
+         }
+      }
+   } while (!res);
+
+   if ((flags & MP_PRIME_SAFE) != 0) {
+      /* restore a to the original value */
+      if ((err = mp_mul_2(a, a)) != MP_OKAY) {
+         goto LBL_ERR;
+      }
+      if ((err = mp_add_d(a, 1uL, a)) != MP_OKAY) {
+         goto LBL_ERR;
+      }
+   }
+
+   err = MP_OKAY;
+LBL_ERR:
+   MP_FREE_BUF(tmp, (size_t)bsize);
+   return err;
+}
+void s_mp_zero_buf(void *mem, size_t size)
+{
+#ifdef MP_USE_MEMOPS
+  memset(mem, 0, size);
+#else
+  char *m = (char *)mem;
+  while (size-- > 0u) {
+    *m++ = '\0';
+  }
+#endif
+}
+//=================================libtomath=================================
+
 namespace yacl::math {
 
 namespace {
@@ -165,7 +499,7 @@ void mpx_safe_prime_rand(mp_int *p, int t, int psize) {
 
   do {
     /* read the bytes */
-    MPINT_ENFORCE_OK(s_mp_rand_source(tmp, (size_t)bsize));
+    MPINT_ENFORCE_OK(s_mp_rand_platform(tmp, (size_t)bsize));
 
     // clear bits in the first byte
     tmp[0] &= maskAND;
@@ -234,7 +568,7 @@ void mpx_rand_bits(mp_int *out, int64_t bits) {
   MPINT_ENFORCE_OK(mp_grow(out, digits));
 
   MPINT_ENFORCE_OK(
-      s_mp_rand_source(out->dp, (size_t)digits * sizeof(mp_digit)));
+      s_mp_rand_platform(out->dp, (size_t)digits * sizeof(mp_digit)));
 
   out->sign = MP_ZPOS;
   out->used = digits;
